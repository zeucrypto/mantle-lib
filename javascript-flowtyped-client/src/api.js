// @flow
/* eslint-disable no-use-before-define */
/**
 * Mantle API
 * Most endpoints require authentication with an <strong>API key</strong><br><br>                                         You must first authenticate with your account by logging in your account on <strong><a target=\'_blank\' href=\'https://www.mantleblockchain.com\'/>mantleblockchain.com</a></strong>.<br>                                         Then, you will need to navigate to the <strong>My API Key</strong> page in the Settings section.<br>                                         You need to have the role administrator of your organization to generate an <strong>API Key</strong>.<br><br>                                         Then use this <strong>API Key</strong> in all your requests with the following header:<br><br>                                         <strong>[ x-api-key: API_KEY ]</strong><br><br>For more information on the different product and more, you can refer to the <a target=\'_blank\' href=\'https://docs.mantleblockchain.com/v1.0/documentation/home\'><strong>knowledge base</strong></a>
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "http://develop.api.mantleblockchain.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}


/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type AnonymousApiKeyResponse = {
    /**
     * 
     * @type {string}
     * @memberof AnonymousApiKeyResponse
     */
    userEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof AnonymousApiKeyResponse
     */
    userId?: string;
    /**
     * 
     * @type {Date}
     * @memberof AnonymousApiKeyResponse
     */
    creationDate?: Date;
}



            export type AssetBalanceTypeEnum = 'Asset' | 'MultiAsset';
/**
 * 
 * @export
 */
export type AssetBalance = {
    /**
     * 
     * @type {string}
     * @memberof AssetBalance
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetBalance
     */
    displayName?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetBalance
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetBalance
     */
    type?: AssetBalanceTypeEnum;
}



            export type AssetTransactionBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';
/**
 * 
 * @export
 */
export type AssetTransaction = {
    /**
     * 
     * @type {string}
     * @memberof AssetTransaction
     */
    blockchainStatus?: AssetTransactionBlockchainStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetTransaction
     */
    assetId?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetTransaction
     */
    assetDisplayName?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetTransaction
     */
    metaData?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetTransaction
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetTransaction
     */
    batchId?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetTransaction
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetTransaction
     */
    senderDisplayName?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetTransaction
     */
    recipientDisplayName?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetTransaction
     */
    timestamp?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AssetTransaction
     */
    isReverted?: boolean;
}


/**
 * 
 * @export
 */
export type Batch = {
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    batchId?: string;
    /**
     * 
     * @type {number}
     * @memberof Batch
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof Batch
     */
    timestamp?: number;
}


/**
 * 
 * @export
 */
export type BreadcrumbingCompareResponse = {
    /**
     * 
     * @type {number}
     * @memberof BreadcrumbingCompareResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {string}
     * @memberof BreadcrumbingCompareResponse
     */
    fileUrl?: string;
}



            export type ContractContractStatusEnum = 'Unsigned' | 'PartiallySigned' | 'CurrentlySigning' | 'Signed';

            export type ContractBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';
/**
 * 
 * @export
 */
export type Contract = {
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    contractStatus?: ContractContractStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof Contract
     */
    signerIdentifiers?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    blockchainStatus?: ContractBlockchainStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    ownerEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    displayName?: string;
    /**
     * 
     * @type {Date}
     * @memberof Contract
     */
    creationDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Contract
     */
    isDeleted?: boolean;
}


/**
 * 
 * @export
 */
export type ContractSignatureDiffResponse = {
    /**
     * 
     * @type {string}
     * @memberof ContractSignatureDiffResponse
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ContractSignatureDiffResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {string}
     * @memberof ContractSignatureDiffResponse
     */
    fileUrl?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContractSignatureDiffResponse
     */
    changedText?: Array<string>;
}


/**
 * 
 * @export
 */
export type CreateApiKeyRequest = {
    /**
     * 
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    userId: string;
}


/**
 * 
 * @export
 */
export type CreateEntityRequest = {
    /**
     * 
     * @type {string}
     * @memberof CreateEntityRequest
     */
    ownedIdentifier: string;
}



            export type EditUserRequestRolesEnum = 'MCKeeperAdmin' | 'MCBilling' | 'MCUserAdmin' | 'MCTrackerAdmin' | 'MCTrackerUser' | 'MCSealerAdmin' | 'MCSealerUser' | 'MCAdmin';
/**
 * 
 * @export
 */
export type EditUserRequest = {
    /**
     * 
     * @type {string}
     * @memberof EditUserRequest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof EditUserRequest
     */
    lastName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EditUserRequest
     */
    roles: Array<EditUserRequestRolesEnum>;
}



            export type HttpExposedErrorErrorCodeEnum = 'Core_Unhandled' | 'Core_WavesSpendingLimitReached' | 'Client_ConfigNotFound' | 'Client_ConfigNotConfirmed' | 'Client_ConfigAlreadyExists' | 'Client_ProductAlreadyExists' | 'Breadcrumbing_InvalidImageSize' | 'Breadcrumbing_FileTypesDoNotMatch' | 'Breadcrumbing_FileNotFound' | 'Breadcrumbing_FileNotConfirmed' | 'Breadcrumbing_StackedFileNotConfirmed' | 'Breadcrumbing_FileAlreadyExists' | 'Breadcrumbing_InvalidFileFormat' | 'Breadcrumbing_VersionNotFound' | 'Breadcrumbing_VersionNotConfirmed' | 'Breadcrumbing_NotSupportedFileFormat' | 'Factory_IssueAmountCantBeZero' | 'Factory_IssueAmountTooHigh' | 'Factory_TransferAmountCantBeZero' | 'Factory_TransferAmountTooHigh' | 'Factory_CannotRevertInvalidAttachment' | 'Factory_CannotRevertAssetIssue' | 'Factory_CannotDeleteInheritedFactory' | 'Factory_StackedFactoryDuplicateFactory' | 'Factory_StackedFactoryWithoutFactory' | 'Factory_CannotRevertTransactionAlreadySpent' | 'Factory_FactoryNotFound' | 'Factory_StackedFactoryNotFound' | 'Factory_TransactionNotFound' | 'Factory_FactoryNotConfirmed' | 'Factory_StackedFactoryNotConfirmed' | 'Factory_TransactionNotConfirmed' | 'Factory_ReversalNotConfirmed' | 'Factory_FactoryAlreadyExists' | 'Factory_StackedFactoryAlreadyExists' | 'Factory_TransactionAlreadyExists' | 'Factory_TransactionWasAlreadyReversed' | 'Factory_FactoryTransferInsufficientFund' | 'User_NotFound' | 'User_NotConfirmed' | 'User_AlreadyExists' | 'Identity_StackedIdentityDuplicateSubIdentity' | 'Identity_SubIdentityNotFound' | 'Identity_StackedIdentityAlreadyExists' | 'Identity_StackedIdentityNotFound' | 'Identity_DeleteNotFound' | 'Identity_UpdateNotFound' | 'Identity_NotFound' | 'Identity_NotConfirmed' | 'Identity_NotTheOwner' | 'Rule_AlreadyExists' | 'Rule_MaximumDailyTransactionCount' | 'Rule_MaximumAmountPerTransaction' | 'Rule_MaximumYearlyTotalInput';
/**
 * 
 * @export
 */
export type HttpExposedError = {
    /**
     * 
     * @type {string}
     * @memberof HttpExposedError
     */
    errorCode?: HttpExposedErrorErrorCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof HttpExposedError
     */
    message?: string;
    /**
     * 
     * @type {Array<Object>}
     * @memberof HttpExposedError
     */
    _arguments?: Array<Object>;
}


/**
 * 
 * @export
 */
export type IFormFile = {
    /**
     * 
     * @type {string}
     * @memberof IFormFile
     */
    contentType?: string;
    /**
     * 
     * @type {string}
     * @memberof IFormFile
     */
    contentDisposition?: string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof IFormFile
     */
    headers?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {number}
     * @memberof IFormFile
     */
    length?: number;
    /**
     * 
     * @type {string}
     * @memberof IFormFile
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IFormFile
     */
    fileName?: string;
}



            export type InvitationStatusEnum = 'Pending' | 'Accepted' | 'Deleted';

            export type InvitationRolesEnum = 'MCKeeperAdmin' | 'MCBilling' | 'MCUserAdmin' | 'MCTrackerAdmin' | 'MCTrackerUser' | 'MCSealerAdmin' | 'MCSealerUser' | 'MCAdmin';
/**
 * 
 * @export
 */
export type Invitation = {
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    newUserEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    status?: InvitationStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof Invitation
     */
    roles?: Array<InvitationRolesEnum>;
    /**
     * 
     * @type {Date}
     * @memberof Invitation
     */
    creationDateTime?: Date;
}



            export type InvitationCreateRequestRolesEnum = 'MCKeeperAdmin' | 'MCBilling' | 'MCUserAdmin' | 'MCTrackerAdmin' | 'MCTrackerUser' | 'MCSealerAdmin' | 'MCSealerUser' | 'MCAdmin';
/**
 * 
 * @export
 */
export type InvitationCreateRequest = {
    /**
     * 
     * @type {string}
     * @memberof InvitationCreateRequest
     */
    email: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvitationCreateRequest
     */
    roles?: Array<InvitationCreateRequestRolesEnum>;
}


/**
 * 
 * @export
 */
export type InvitationSignUpResponse = {
    /**
     * 
     * @type {Invitation}
     * @memberof InvitationSignUpResponse
     */
    invitation?: Invitation;
    /**
     * 
     * @type {string}
     * @memberof InvitationSignUpResponse
     */
    clientName?: string;
}


/**
 * 
 * @export
 */
export type IssuedBatchTransactionsResponse = {
    /**
     * 
     * @type {number}
     * @memberof IssuedBatchTransactionsResponse
     */
    batchTimestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof IssuedBatchTransactionsResponse
     */
    assetDisplayName?: string;
    /**
     * 
     * @type {Array<AssetTransaction>}
     * @memberof IssuedBatchTransactionsResponse
     */
    transactions?: Array<AssetTransaction>;
}


/**
 * 
 * @export
 */
export type IssuedBatchesResponse = {
    /**
     * 
     * @type {string}
     * @memberof IssuedBatchesResponse
     */
    assetDisplayName?: string;
    /**
     * 
     * @type {Array<AssetTransaction>}
     * @memberof IssuedBatchesResponse
     */
    batches?: Array<AssetTransaction>;
}



            export type KeeperFileFileTypeEnum = 'Image' | 'Text' | 'Binary' | 'Json' | 'Xml' | 'Pdf';

            export type KeeperFileAccuracyLevelEnum = 'Lowest' | 'Low' | 'Medium' | 'High' | 'Excellent';

            export type KeeperFileBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';
/**
 * 
 * @export
 */
export type KeeperFile = {
    /**
     * 
     * @type {string}
     * @memberof KeeperFile
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof KeeperFile
     */
    fileType?: KeeperFileFileTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof KeeperFile
     */
    accuracyLevel?: KeeperFileAccuracyLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof KeeperFile
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof KeeperFile
     */
    blockchainStatus?: KeeperFileBlockchainStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof KeeperFile
     */
    ownerEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof KeeperFile
     */
    displayName?: string;
    /**
     * 
     * @type {Date}
     * @memberof KeeperFile
     */
    creationDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof KeeperFile
     */
    isDeleted?: boolean;
}



            export type KeeperFileVersionBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';
/**
 * 
 * @export
 */
export type KeeperFileVersion = {
    /**
     * 
     * @type {number}
     * @memberof KeeperFileVersion
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof KeeperFileVersion
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof KeeperFileVersion
     */
    blockchainStatus?: KeeperFileVersionBlockchainStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof KeeperFileVersion
     */
    ownerEmail?: string;
    /**
     * 
     * @type {Date}
     * @memberof KeeperFileVersion
     */
    creationDate?: Date;
}


/**
 * 
 * @export
 */
export type KeeperFolder = {
    /**
     * 
     * @type {string}
     * @memberof KeeperFolder
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof KeeperFolder
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof KeeperFolder
     */
    subscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof KeeperFolder
     */
    createdById?: string;
    /**
     * 
     * @type {string}
     * @memberof KeeperFolder
     */
    createdByEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof KeeperFolder
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof KeeperFolder
     */
    fileQuantity?: number;
    /**
     * 
     * @type {Date}
     * @memberof KeeperFolder
     */
    creationDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof KeeperFolder
     */
    modificationDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof KeeperFolder
     */
    isDeleted?: boolean;
}


/**
 * 
 * @export
 */
export type KeeperFolderCreateRequest = {
    /**
     * 
     * @type {string}
     * @memberof KeeperFolderCreateRequest
     */
    name: string;
}



            export type KeeperProductSubscriptionBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';

            export type KeeperProductSubscriptionProductEnum = 'Tracker' | 'Keeper' | 'Sealer';
/**
 * 
 * @export
 */
export type KeeperProductSubscription = {
    /**
     * 
     * @type {string}
     * @memberof KeeperProductSubscription
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof KeeperProductSubscription
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof KeeperProductSubscription
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof KeeperProductSubscription
     */
    blockchainStatus?: KeeperProductSubscriptionBlockchainStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof KeeperProductSubscription
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof KeeperProductSubscription
     */
    product?: KeeperProductSubscriptionProductEnum;
}


/**
 * 
 * @export
 */
export type MultiStatusResult = {
    /**
     * 
     * @type {number}
     * @memberof MultiStatusResult
     */
    statusCode?: number;
    /**
     * 
     * @type {HttpExposedError}
     * @memberof MultiStatusResult
     */
    error?: HttpExposedError;
}



            export type NonUserStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';
/**
 * 
 * @export
 */
export type NonUser = {
    /**
     * 
     * @type {string}
     * @memberof NonUser
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NonUser
     */
    identifier?: string;
    /**
     * 
     * @type {string}
     * @memberof NonUser
     */
    ownerIdentifier?: string;
    /**
     * 
     * @type {string}
     * @memberof NonUser
     */
    status?: NonUserStatusEnum;
}



            export type NonUserResponseStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';
/**
 * 
 * @export
 */
export type NonUserResponse = {
    /**
     * 
     * @type {string}
     * @memberof NonUserResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NonUserResponse
     */
    status?: NonUserResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof NonUserResponse
     */
    ownerIdentityId?: string;
    /**
     * 
     * @type {string}
     * @memberof NonUserResponse
     */
    ownerIdentityDisplayName?: string;
    /**
     * 
     * @type {string}
     * @memberof NonUserResponse
     */
    ownedIdentityId?: string;
    /**
     * 
     * @type {string}
     * @memberof NonUserResponse
     */
    ownedIdentityDisplayName?: string;
    /**
     * 
     * @type {number}
     * @memberof NonUserResponse
     */
    timestamp?: number;
}



            export type ProductMenuOptionProductEnum = 'Tracker' | 'Keeper' | 'Sealer';
/**
 * 
 * @export
 */
export type ProductMenuOption = {
    /**
     * 
     * @type {string}
     * @memberof ProductMenuOption
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductMenuOption
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductMenuOption
     */
    product?: ProductMenuOptionProductEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ProductMenuOption
     */
    available?: boolean;
}



            export type ProductSubscriptionBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';

            export type ProductSubscriptionProductEnum = 'Tracker' | 'Keeper' | 'Sealer';
/**
 * 
 * @export
 */
export type ProductSubscription = {
    /**
     * 
     * @type {string}
     * @memberof ProductSubscription
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof ProductSubscription
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ProductSubscription
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ProductSubscription
     */
    blockchainStatus?: ProductSubscriptionBlockchainStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductSubscription
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductSubscription
     */
    product?: ProductSubscriptionProductEnum;
}


/**
 * 
 * @export
 */
export type SealerBreadcrumbingCompareResponse = {
    /**
     * 
     * @type {number}
     * @memberof SealerBreadcrumbingCompareResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {string}
     * @memberof SealerBreadcrumbingCompareResponse
     */
    fileUrl?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SealerBreadcrumbingCompareResponse
     */
    changedText?: Array<string>;
}



            export type SealerProductSubscriptionBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';

            export type SealerProductSubscriptionProductEnum = 'Tracker' | 'Keeper' | 'Sealer';
/**
 * 
 * @export
 */
export type SealerProductSubscription = {
    /**
     * 
     * @type {string}
     * @memberof SealerProductSubscription
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof SealerProductSubscription
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SealerProductSubscription
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof SealerProductSubscription
     */
    blockchainStatus?: SealerProductSubscriptionBlockchainStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SealerProductSubscription
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SealerProductSubscription
     */
    product?: SealerProductSubscriptionProductEnum;
    /**
     * 
     * @type {SealerProductSubscriptionSettings}
     * @memberof SealerProductSubscription
     */
    settings?: SealerProductSubscriptionSettings;
}


/**
 * 
 * @export
 */
export type SealerProductSubscriptionSettings = {
    /**
     * 
     * @type {string}
     * @memberof SealerProductSubscriptionSettings
     */
    mode?: string;
}



            export type SignatureBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';
/**
 * 
 * @export
 */
export type Signature = {
    /**
     * 
     * @type {string}
     * @memberof Signature
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Signature
     */
    blockchainStatus?: SignatureBlockchainStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Signature
     */
    ownerEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof Signature
     */
    displayName?: string;
    /**
     * 
     * @type {Date}
     * @memberof Signature
     */
    creationDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Signature
     */
    isDeleted?: boolean;
}


/**
 * 
 * @export
 */
export type SubAssetIdentity = {
    /**
     * 
     * @type {string}
     * @memberof SubAssetIdentity
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SubAssetIdentity
     */
    displayName?: string;
}



            export type TemplateBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';
/**
 * 
 * @export
 */
export type Template = {
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    blockchainStatus?: TemplateBlockchainStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    ownerEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    displayName?: string;
    /**
     * 
     * @type {Date}
     * @memberof Template
     */
    creationDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Template
     */
    isDeleted?: boolean;
}



            export type TrackerAssetBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';
/**
 * 
 * @export
 */
export type TrackerAsset = {
    /**
     * 
     * @type {string}
     * @memberof TrackerAsset
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerAsset
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerAsset
     */
    blockchainStatus?: TrackerAssetBlockchainStatusEnum;
    /**
     * 
     * @type {Date}
     * @memberof TrackerAsset
     */
    creationDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof TrackerAsset
     */
    isDeleted?: boolean;
}


/**
 * 
 * @export
 */
export type TrackerAssetCreateRequest = {
    /**
     * 
     * @type {string}
     * @memberof TrackerAssetCreateRequest
     */
    name: string;
}


/**
 * 
 * @export
 */
export type TrackerAssetIssueBulkRequest = {
    /**
     * 
     * @type {string}
     * @memberof TrackerAssetIssueBulkRequest
     */
    assetId: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerAssetIssueBulkRequest
     */
    ownedId?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerAssetIssueBulkRequest
     */
    recipientEmail: string;
    /**
     * 
     * @type {number}
     * @memberof TrackerAssetIssueBulkRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof TrackerAssetIssueBulkRequest
     */
    metaData?: string;
}


/**
 * 
 * @export
 */
export type TrackerAssetIssueRequest = {
    /**
     * 
     * @type {string}
     * @memberof TrackerAssetIssueRequest
     */
    recipientDisplayName: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerAssetIssueRequest
     */
    ownedDisplayName?: string;
    /**
     * 
     * @type {number}
     * @memberof TrackerAssetIssueRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof TrackerAssetIssueRequest
     */
    metaData?: string;
}


/**
 * 
 * @export
 */
export type TrackerAssetIssueResponse = {
    /**
     * 
     * @type {TrackerAssetIssueBulkRequest}
     * @memberof TrackerAssetIssueResponse
     */
    issueRequest?: TrackerAssetIssueBulkRequest;
    /**
     * 
     * @type {MultiStatusResult}
     * @memberof TrackerAssetIssueResponse
     */
    issueResult?: MultiStatusResult;
}


/**
 * 
 * @export
 */
export type TrackerBatchTransferBulkRequest = {
    /**
     * 
     * @type {string}
     * @memberof TrackerBatchTransferBulkRequest
     */
    assetId: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerBatchTransferBulkRequest
     */
    recipientEmail: string;
    /**
     * 
     * @type {number}
     * @memberof TrackerBatchTransferBulkRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof TrackerBatchTransferBulkRequest
     */
    metaData?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackerBatchTransferBulkRequest
     */
    batchIds?: Array<string>;
}


/**
 * 
 * @export
 */
export type TrackerBatchTransferBulkResponse = {
    /**
     * 
     * @type {TrackerBatchTransferBulkRequest}
     * @memberof TrackerBatchTransferBulkResponse
     */
    batchTransferBulkRequest?: TrackerBatchTransferBulkRequest;
    /**
     * 
     * @type {MultiStatusResult}
     * @memberof TrackerBatchTransferBulkResponse
     */
    transferResult?: MultiStatusResult;
}


/**
 * 
 * @export
 */
export type TrackerBatchTransferRequest = {
    /**
     * 
     * @type {string}
     * @memberof TrackerBatchTransferRequest
     */
    recipientDisplayName: string;
    /**
     * 
     * @type {number}
     * @memberof TrackerBatchTransferRequest
     */
    amount: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackerBatchTransferRequest
     */
    batchIds: Array<string>;
}



            export type TrackerMultiAssetBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';
/**
 * 
 * @export
 */
export type TrackerMultiAsset = {
    /**
     * 
     * @type {Array<SubAssetIdentity>}
     * @memberof TrackerMultiAsset
     */
    assets?: Array<SubAssetIdentity>;
    /**
     * 
     * @type {string}
     * @memberof TrackerMultiAsset
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMultiAsset
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMultiAsset
     */
    blockchainStatus?: TrackerMultiAssetBlockchainStatusEnum;
    /**
     * 
     * @type {Date}
     * @memberof TrackerMultiAsset
     */
    creationDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof TrackerMultiAsset
     */
    isDeleted?: boolean;
}


/**
 * 
 * @export
 */
export type TrackerMultiAssetCreateRequest = {
    /**
     * 
     * @type {string}
     * @memberof TrackerMultiAssetCreateRequest
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackerMultiAssetCreateRequest
     */
    assetIds?: Array<string>;
    /**
     * Will create an asset if none exists with that name, otherwise will use the existing asset
     * @type {Array<string>}
     * @memberof TrackerMultiAssetCreateRequest
     */
    assetDisplayNames?: Array<string>;
}



            export type TrackerProductSubscriptionBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';

            export type TrackerProductSubscriptionProductEnum = 'Tracker' | 'Keeper' | 'Sealer';
/**
 * 
 * @export
 */
export type TrackerProductSubscription = {
    /**
     * 
     * @type {string}
     * @memberof TrackerProductSubscription
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof TrackerProductSubscription
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TrackerProductSubscription
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof TrackerProductSubscription
     */
    blockchainStatus?: TrackerProductSubscriptionBlockchainStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TrackerProductSubscription
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerProductSubscription
     */
    product?: TrackerProductSubscriptionProductEnum;
}


/**
 * 
 * @export
 */
export type TrackerTransferRequest = {
    /**
     * 
     * @type {string}
     * @memberof TrackerTransferRequest
     */
    recipientDisplayName: string;
    /**
     * 
     * @type {number}
     * @memberof TrackerTransferRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof TrackerTransferRequest
     */
    metaData?: string;
}


/**
 * 
 * @export
 */
export type UpdateEntityRequest = {
    /**
     * 
     * @type {string}
     * @memberof UpdateEntityRequest
     */
    newDisplayName: string;
}


/**
 * 
 * @export
 */
export type UpdateKeeperProductRequest = {
    /**
     * 
     * @type {string}
     * @memberof UpdateKeeperProductRequest
     */
    name: string;
}


/**
 * 
 * @export
 */
export type UpdateSealerProductRequest = {
    /**
     * 
     * @type {string}
     * @memberof UpdateSealerProductRequest
     */
    name: string;
}


/**
 * 
 * @export
 */
export type UpdateTrackerProductRequest = {
    /**
     * 
     * @type {string}
     * @memberof UpdateTrackerProductRequest
     */
    name: string;
}



            export type UserBlockchainStatusEnum = 'Unconfirmed' | 'Confirmed' | 'Corrupted';

            export type UserRolesEnum = 'MCKeeperAdmin' | 'MCBilling' | 'MCUserAdmin' | 'MCTrackerAdmin' | 'MCTrackerUser' | 'MCSealerAdmin' | 'MCSealerUser' | 'MCAdmin';
/**
 * 
 * @export
 */
export type User = {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    isEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    blockchainStatus?: UserBlockchainStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    roles?: Array<UserRolesEnum>;
}




/**
 * ApiKeysApi - fetch parameter creator
 * @export
 */
export const ApiKeysApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Requires the User Admin Role.
         * @summary Create an API key for a specific user
         * @throws {RequiredError}
         */
        createApiKey(xApiKey: string, request?: CreateApiKeyRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createApiKey.');
            }
            const localVarPath = `/apikeys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the User Admin Role.
         * @summary Delete the API key for a specific user
         * @throws {RequiredError}
         */
        deleteApiKey(userId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteApiKey.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling deleteApiKey.');
            }
            const localVarPath = `/apikeys/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the User Admin Role.
         * @summary Get all generated api keys
         * @throws {RequiredError}
         */
        getAllApiKeys(xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllApiKeys.');
            }
            const localVarPath = `/apikeys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ApiKeysApiType = { 
    createApiKey(xApiKey: string, request?: CreateApiKeyRequest, options?: RequestOptions): Promise<Response>,

    deleteApiKey(userId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,

    getAllApiKeys(xApiKey: string, options?: RequestOptions): Promise<Array<AnonymousApiKeyResponse>>,
}

/**
 * ApiKeysApi - factory function to inject configuration 
 * @export
 */
export const ApiKeysApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ApiKeysApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Requires the User Admin Role.
         * @summary Create an API key for a specific user
         * @throws {RequiredError}
         */
        createApiKey(xApiKey: string, request?: CreateApiKeyRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).createApiKey(xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the User Admin Role.
         * @summary Delete the API key for a specific user
         * @throws {RequiredError}
         */
        deleteApiKey(userId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).deleteApiKey(userId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the User Admin Role.
         * @summary Get all generated api keys
         * @throws {RequiredError}
         */
        getAllApiKeys(xApiKey: string, options?: RequestOptions = {}): Promise<Array<AnonymousApiKeyResponse>> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).getAllApiKeys(xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * InvitationsApi - fetch parameter creator
 * @export
 */
export const InvitationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Invite a user to join the platform. The entered email will be used to confirm the user\'s  entity. An invitation email will also be sent.                Requires the User Admin Role.
         * @summary Create an invitation
         * @throws {RequiredError}
         */
        createInvitation(xApiKey: string, request?: InvitationCreateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createInvitation.');
            }
            const localVarPath = `/invitations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The invited user won\'t be able to join the platform anymore. An invitation can be created with the same email again.                Requires the User Admin Role.
         * @summary Delete a specific invitation
         * @throws {RequiredError}
         */
        deleteInvitation(invitationId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'invitationId' is not null or undefined
            if (invitationId === null || invitationId === undefined) {
                throw new RequiredError('invitationId','Required parameter invitationId was null or undefined when calling deleteInvitation.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling deleteInvitation.');
            }
            const localVarPath = `/invitations/{invitationId}`
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the User Admin Role.
         * @summary Get all invitations
         * @throws {RequiredError}
         */
        getAllInvitations(xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllInvitations.');
            }
            const localVarPath = `/invitations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an invitation\'s details
         * @throws {RequiredError}
         */
        getInvitationById(invitationId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'invitationId' is not null or undefined
            if (invitationId === null || invitationId === undefined) {
                throw new RequiredError('invitationId','Required parameter invitationId was null or undefined when calling getInvitationById.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getInvitationById.');
            }
            const localVarPath = `/invitations/{invitationId}`
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type InvitationsApiType = { 
    createInvitation(xApiKey: string, request?: InvitationCreateRequest, options?: RequestOptions): Promise<Invitation>,

    deleteInvitation(invitationId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,

    getAllInvitations(xApiKey: string, options?: RequestOptions): Promise<Array<Invitation>>,

    getInvitationById(invitationId: string, xApiKey: string, options?: RequestOptions): Promise<InvitationSignUpResponse>,
}

/**
 * InvitationsApi - factory function to inject configuration 
 * @export
 */
export const InvitationsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): InvitationsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Invite a user to join the platform. The entered email will be used to confirm the user\'s  entity. An invitation email will also be sent.                Requires the User Admin Role.
         * @summary Create an invitation
         * @throws {RequiredError}
         */
        createInvitation(xApiKey: string, request?: InvitationCreateRequest, options?: RequestOptions = {}): Promise<Invitation> {
            const localVarFetchArgs = InvitationsApiFetchParamCreator(configuration).createInvitation(xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * The invited user won\'t be able to join the platform anymore. An invitation can be created with the same email again.                Requires the User Admin Role.
         * @summary Delete a specific invitation
         * @throws {RequiredError}
         */
        deleteInvitation(invitationId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = InvitationsApiFetchParamCreator(configuration).deleteInvitation(invitationId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the User Admin Role.
         * @summary Get all invitations
         * @throws {RequiredError}
         */
        getAllInvitations(xApiKey: string, options?: RequestOptions = {}): Promise<Array<Invitation>> {
            const localVarFetchArgs = InvitationsApiFetchParamCreator(configuration).getAllInvitations(xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get an invitation\'s details
         * @throws {RequiredError}
         */
        getInvitationById(invitationId: string, xApiKey: string, options?: RequestOptions = {}): Promise<InvitationSignUpResponse> {
            const localVarFetchArgs = InvitationsApiFetchParamCreator(configuration).getInvitationById(invitationId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * KeeperApi - fetch parameter creator
 * @export
 */
export const KeeperApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It will compare their fingerprint against each other to find the differences.  The GenerateDiffFile property is false by default, and if it is set to true and the file to compare\'s type is  either Text, JSON or an image, then a file highlighting the differences will be generated.                Requires the Keeper Admin Role.
         * @summary [VERSIONS] Compare a local file to a version
         * @throws {RequiredError}
         */
        compareVersion(fileId: string, versionId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling compareVersion.');
            }
            // verify required parameter 'versionId' is not null or undefined
            if (versionId === null || versionId === undefined) {
                throw new RequiredError('versionId','Required parameter versionId was null or undefined when calling compareVersion.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling compareVersion.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling compareVersion.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling compareVersion.');
            }
            const localVarPath = `/keeper/{productId}/files/{fileId}/versions/compare/{versionId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (mustGenerateCompareResult !== undefined) {
                localVarFormParams.set('mustGenerateCompareResult', ((mustGenerateCompareResult:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compare a local file to the latest version of a file that\'s been stored in the blockchain. It will compare their  fingerprint against each other to find the differences.  The MustGenerateCompareResult property is false by default, and if it is set to true and the file\'s type is  either Text, JSON or an image, then a file highlighting the differences will be generated.                Requires the Keeper Admin Role.
         * @summary [FILES] Compare a local file to the latest version
         * @throws {RequiredError}
         */
        compareWithLatestFileVersion(fileId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling compareWithLatestFileVersion.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling compareWithLatestFileVersion.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling compareWithLatestFileVersion.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling compareWithLatestFileVersion.');
            }
            const localVarPath = `/keeper/{productId}/files/{fileId}/compare/latest`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (mustGenerateCompareResult !== undefined) {
                localVarFormParams.set('mustGenerateCompareResult', ((mustGenerateCompareResult:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compare a local file to the original version of a file that\'s been stored in the blockchain. It will compare their  fingerprint against each other to find the differences.  The MustGenerateCompareResult property is false by default, and if it is set to true and the file\'s type is  either Text, JSON or an image, then a file highlighting the differences will be generated.                Requires the Keeper Admin Role.
         * @summary [FILES] Compare a local file to the original version
         * @throws {RequiredError}
         */
        compareWithOriginalFile(fileId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling compareWithOriginalFile.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling compareWithOriginalFile.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling compareWithOriginalFile.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling compareWithOriginalFile.');
            }
            const localVarPath = `/keeper/{productId}/files/{fileId}/compare/original`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (mustGenerateCompareResult !== undefined) {
                localVarFormParams.set('mustGenerateCompareResult', ((mustGenerateCompareResult:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will create a cryptographic representation of the file and store its fingerprint in the blockchain.                Requires the Keeper Admin Role.
         * @summary [FILES] Create a file
         * @throws {RequiredError}
         */
        createFile(productId: string, xApiKey: string, accuracy: string, file: any, displayName: string, folderId?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createFile.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createFile.');
            }
            // verify required parameter 'accuracy' is not null or undefined
            if (accuracy === null || accuracy === undefined) {
                throw new RequiredError('accuracy','Required parameter accuracy was null or undefined when calling createFile.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createFile.');
            }
            // verify required parameter 'displayName' is not null or undefined
            if (displayName === null || displayName === undefined) {
                throw new RequiredError('displayName','Required parameter displayName was null or undefined when calling createFile.');
            }
            const localVarPath = `/keeper/{productId}/files`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (accuracy !== undefined) {
                localVarFormParams.set('accuracy', ((accuracy:any):string));
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (displayName !== undefined) {
                localVarFormParams.set('displayName', ((displayName:any):string));
            }

            if (folderId !== undefined) {
                localVarFormParams.set('folderId', ((folderId:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A folder is necessary to add files in Keeper.                Requires the Keeper Admin Role.
         * @summary [FOLDERS] Create a folder
         * @throws {RequiredError}
         */
        createFolder(productId: string, xApiKey: string, request?: KeeperFolderCreateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createFolder.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createFolder.');
            }
            const localVarPath = `/keeper/{productId}/folders`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This new version will also have its fingerprint stored in the blockchain.                Requires the Keeper Admin Role.
         * @summary [VERSIONS] Create a version for an existing file
         * @throws {RequiredError}
         */
        createVersion(fileId: string, productId: string, xApiKey: string, file: any, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling createVersion.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createVersion.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createVersion.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createVersion.');
            }
            const localVarPath = `/keeper/{productId}/files/{fileId}/versions`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Its fingerprint will stay in the blockchain, but it will not be accessible and visible.                Requires the Keeper Admin Role.
         * @summary [FILES] Delete a file
         * @throws {RequiredError}
         */
        deleteFileById(fileId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling deleteFileById.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteFileById.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling deleteFileById.');
            }
            const localVarPath = `/keeper/{productId}/files/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will also delete all the files it contains.                Requires the Keeper Admin Role.
         * @summary [FOLDERS] Delete a folder
         * @throws {RequiredError}
         */
        deleteFolder(productId: string, folderId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteFolder.');
            }
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new RequiredError('folderId','Required parameter folderId was null or undefined when calling deleteFolder.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling deleteFolder.');
            }
            const localVarPath = `/keeper/{productId}/folders/{folderId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify if the file\'s fingerprint exist.                Requires the Keeper Admin Role.
         * @summary [FILES] Check if a file already exists
         * @throws {RequiredError}
         */
        doesFileExist(productId: string, xApiKey: string, accuracy: string, file: any, folderId?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling doesFileExist.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling doesFileExist.');
            }
            // verify required parameter 'accuracy' is not null or undefined
            if (accuracy === null || accuracy === undefined) {
                throw new RequiredError('accuracy','Required parameter accuracy was null or undefined when calling doesFileExist.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling doesFileExist.');
            }
            const localVarPath = `/keeper/{productId}/files/exist`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (accuracy !== undefined) {
                localVarFormParams.set('accuracy', ((accuracy:any):string));
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (folderId !== undefined) {
                localVarFormParams.set('folderId', ((folderId:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the files stored in Keeper.                Requires the Keeper Admin Role.
         * @summary [FILES] Get all files
         * @throws {RequiredError}
         */
        getAllFiles(productId: string, xApiKey: string, displayName?: string, limit?: number, offset?: number, folderId?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAllFiles.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllFiles.');
            }
            const localVarPath = `/keeper/{productId}/files`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (displayName !== undefined) {
                localVarQueryParameter['displayName'] = ((displayName:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = ((folderId:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all folders that have been created in Keeper.                Requires the Keeper Admin Role.
         * @summary [FOLDERS] Get all folders
         * @throws {RequiredError}
         */
        getAllFolders(productId: string, xApiKey: string, name?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAllFolders.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllFolders.');
            }
            const localVarPath = `/keeper/{productId}/folders`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Keeper Admin Role.
         * @summary [VERSIONS] Get all the versions\' details for a file
         * @throws {RequiredError}
         */
        getAllVersions(fileId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling getAllVersions.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAllVersions.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllVersions.');
            }
            const localVarPath = `/keeper/{productId}/files/{fileId}/versions`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Keeper Admin Role.
         * @summary [FILES] Get a file\'s details.
         * @throws {RequiredError}
         */
        getFileById(fileId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling getFileById.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getFileById.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getFileById.');
            }
            const localVarPath = `/keeper/{productId}/files/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Keeper Admin Role.
         * @summary [FOLDERS] Get folder details
         * @throws {RequiredError}
         */
        getFolderById(productId: string, folderId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getFolderById.');
            }
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new RequiredError('folderId','Required parameter folderId was null or undefined when calling getFolderById.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getFolderById.');
            }
            const localVarPath = `/keeper/{productId}/folders/{folderId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [FILES] Give a link to download the file uploaded to the gcloud bucket
         * @throws {RequiredError}
         */
        getLinkToDownloadOriginalFile(fileId: string, productId: string, xApiKey: string, originalFileId?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling getLinkToDownloadOriginalFile.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getLinkToDownloadOriginalFile.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getLinkToDownloadOriginalFile.');
            }
            const localVarPath = `/keeper/{productId}/files/download/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (originalFileId !== undefined) {
                localVarQueryParameter['originalFileId'] = ((originalFileId:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type KeeperApiType = { 
    compareVersion(fileId: string, versionId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions): Promise<BreadcrumbingCompareResponse>,

    compareWithLatestFileVersion(fileId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions): Promise<BreadcrumbingCompareResponse>,

    compareWithOriginalFile(fileId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions): Promise<BreadcrumbingCompareResponse>,

    createFile(productId: string, xApiKey: string, accuracy: string, file: any, displayName: string, folderId?: string, options?: RequestOptions): Promise<KeeperFile>,

    createFolder(productId: string, xApiKey: string, request?: KeeperFolderCreateRequest, options?: RequestOptions): Promise<KeeperFolder>,

    createVersion(fileId: string, productId: string, xApiKey: string, file: any, options?: RequestOptions): Promise<KeeperFileVersion>,

    deleteFileById(fileId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,

    deleteFolder(productId: string, folderId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,

    doesFileExist(productId: string, xApiKey: string, accuracy: string, file: any, folderId?: string, options?: RequestOptions): Promise<boolean>,

    getAllFiles(productId: string, xApiKey: string, displayName?: string, limit?: number, offset?: number, folderId?: string, options?: RequestOptions): Promise<Array<KeeperFile>>,

    getAllFolders(productId: string, xApiKey: string, name?: string, options?: RequestOptions): Promise<Array<KeeperFolder>>,

    getAllVersions(fileId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<Array<KeeperFileVersion>>,

    getFileById(fileId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<KeeperFile>,

    getFolderById(productId: string, folderId: string, xApiKey: string, options?: RequestOptions): Promise<KeeperFolder>,

    getLinkToDownloadOriginalFile(fileId: string, productId: string, xApiKey: string, originalFileId?: string, options?: RequestOptions): Promise<string>,
}

/**
 * KeeperApi - factory function to inject configuration 
 * @export
 */
export const KeeperApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): KeeperApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * It will compare their fingerprint against each other to find the differences.  The GenerateDiffFile property is false by default, and if it is set to true and the file to compare\'s type is  either Text, JSON or an image, then a file highlighting the differences will be generated.                Requires the Keeper Admin Role.
         * @summary [VERSIONS] Compare a local file to a version
         * @throws {RequiredError}
         */
        compareVersion(fileId: string, versionId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions = {}): Promise<BreadcrumbingCompareResponse> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).compareVersion(fileId, versionId, productId, xApiKey, file, mustGenerateCompareResult, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Compare a local file to the latest version of a file that\'s been stored in the blockchain. It will compare their  fingerprint against each other to find the differences.  The MustGenerateCompareResult property is false by default, and if it is set to true and the file\'s type is  either Text, JSON or an image, then a file highlighting the differences will be generated.                Requires the Keeper Admin Role.
         * @summary [FILES] Compare a local file to the latest version
         * @throws {RequiredError}
         */
        compareWithLatestFileVersion(fileId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions = {}): Promise<BreadcrumbingCompareResponse> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).compareWithLatestFileVersion(fileId, productId, xApiKey, file, mustGenerateCompareResult, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Compare a local file to the original version of a file that\'s been stored in the blockchain. It will compare their  fingerprint against each other to find the differences.  The MustGenerateCompareResult property is false by default, and if it is set to true and the file\'s type is  either Text, JSON or an image, then a file highlighting the differences will be generated.                Requires the Keeper Admin Role.
         * @summary [FILES] Compare a local file to the original version
         * @throws {RequiredError}
         */
        compareWithOriginalFile(fileId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions = {}): Promise<BreadcrumbingCompareResponse> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).compareWithOriginalFile(fileId, productId, xApiKey, file, mustGenerateCompareResult, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This will create a cryptographic representation of the file and store its fingerprint in the blockchain.                Requires the Keeper Admin Role.
         * @summary [FILES] Create a file
         * @throws {RequiredError}
         */
        createFile(productId: string, xApiKey: string, accuracy: string, file: any, displayName: string, folderId?: string, options?: RequestOptions = {}): Promise<KeeperFile> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).createFile(productId, xApiKey, accuracy, file, displayName, folderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * A folder is necessary to add files in Keeper.                Requires the Keeper Admin Role.
         * @summary [FOLDERS] Create a folder
         * @throws {RequiredError}
         */
        createFolder(productId: string, xApiKey: string, request?: KeeperFolderCreateRequest, options?: RequestOptions = {}): Promise<KeeperFolder> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).createFolder(productId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This new version will also have its fingerprint stored in the blockchain.                Requires the Keeper Admin Role.
         * @summary [VERSIONS] Create a version for an existing file
         * @throws {RequiredError}
         */
        createVersion(fileId: string, productId: string, xApiKey: string, file: any, options?: RequestOptions = {}): Promise<KeeperFileVersion> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).createVersion(fileId, productId, xApiKey, file, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Its fingerprint will stay in the blockchain, but it will not be accessible and visible.                Requires the Keeper Admin Role.
         * @summary [FILES] Delete a file
         * @throws {RequiredError}
         */
        deleteFileById(fileId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).deleteFileById(fileId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * This will also delete all the files it contains.                Requires the Keeper Admin Role.
         * @summary [FOLDERS] Delete a folder
         * @throws {RequiredError}
         */
        deleteFolder(productId: string, folderId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).deleteFolder(productId, folderId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Verify if the file\'s fingerprint exist.                Requires the Keeper Admin Role.
         * @summary [FILES] Check if a file already exists
         * @throws {RequiredError}
         */
        doesFileExist(productId: string, xApiKey: string, accuracy: string, file: any, folderId?: string, options?: RequestOptions = {}): Promise<boolean> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).doesFileExist(productId, xApiKey, accuracy, file, folderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all the files stored in Keeper.                Requires the Keeper Admin Role.
         * @summary [FILES] Get all files
         * @throws {RequiredError}
         */
        getAllFiles(productId: string, xApiKey: string, displayName?: string, limit?: number, offset?: number, folderId?: string, options?: RequestOptions = {}): Promise<Array<KeeperFile>> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).getAllFiles(productId, xApiKey, displayName, limit, offset, folderId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all folders that have been created in Keeper.                Requires the Keeper Admin Role.
         * @summary [FOLDERS] Get all folders
         * @throws {RequiredError}
         */
        getAllFolders(productId: string, xApiKey: string, name?: string, options?: RequestOptions = {}): Promise<Array<KeeperFolder>> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).getAllFolders(productId, xApiKey, name, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Keeper Admin Role.
         * @summary [VERSIONS] Get all the versions\' details for a file
         * @throws {RequiredError}
         */
        getAllVersions(fileId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Array<KeeperFileVersion>> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).getAllVersions(fileId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Keeper Admin Role.
         * @summary [FILES] Get a file\'s details.
         * @throws {RequiredError}
         */
        getFileById(fileId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<KeeperFile> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).getFileById(fileId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Keeper Admin Role.
         * @summary [FOLDERS] Get folder details
         * @throws {RequiredError}
         */
        getFolderById(productId: string, folderId: string, xApiKey: string, options?: RequestOptions = {}): Promise<KeeperFolder> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).getFolderById(productId, folderId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary [FILES] Give a link to download the file uploaded to the gcloud bucket
         * @throws {RequiredError}
         */
        getLinkToDownloadOriginalFile(fileId: string, productId: string, xApiKey: string, originalFileId?: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = KeeperApiFetchParamCreator(configuration).getLinkToDownloadOriginalFile(fileId, productId, xApiKey, originalFileId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * ProductsApi - fetch parameter creator
 * @export
 */
export const ProductsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the products for the authenticated user
         * @throws {RequiredError}
         */
        getAllProducts(xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllProducts.');
            }
            const localVarPath = `/products`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Admin role
         * @summary Get a product and its settings
         * @throws {RequiredError}
         */
        getProductById(productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getProductById.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getProductById.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Admin role
         * @summary Update a keeper instance\'s name
         * @throws {RequiredError}
         */
        updateKeeperProduct(productId: string, xApiKey: string, request?: UpdateKeeperProductRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling updateKeeperProduct.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling updateKeeperProduct.');
            }
            const localVarPath = `/products/keeper/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When the Mode is set to API: Signatures must be provided on Contract Creation, Allow non-email Signers, Users cannot sign Contracts by themselves.  When the Mode is set to GUI: Signatures cannot be provided on Contract Creation, Only allow signer emails, An email will be sent to ask for a signature after the contract is confirmed in blockchain, Users must sign the contracts either logged in or using the link in the email that was sent.                Requires the Admin role
         * @summary Update a sealer instance\'s name
         * @throws {RequiredError}
         */
        updateSealerProduct(productId: string, xApiKey: string, request?: UpdateSealerProductRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling updateSealerProduct.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling updateSealerProduct.');
            }
            const localVarPath = `/products/sealer/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Admin role
         * @summary Update a tracker instance\'s name
         * @throws {RequiredError}
         */
        updateTrackerProduct(productId: string, xApiKey: string, request?: UpdateTrackerProductRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling updateTrackerProduct.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling updateTrackerProduct.');
            }
            const localVarPath = `/products/tracker/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ProductsApiType = { 
    getAllProducts(xApiKey: string, options?: RequestOptions): Promise<Array<ProductMenuOption>>,

    getProductById(productId: string, xApiKey: string, options?: RequestOptions): Promise<ProductSubscription>,

    updateKeeperProduct(productId: string, xApiKey: string, request?: UpdateKeeperProductRequest, options?: RequestOptions): Promise<KeeperProductSubscription>,

    updateSealerProduct(productId: string, xApiKey: string, request?: UpdateSealerProductRequest, options?: RequestOptions): Promise<SealerProductSubscription>,

    updateTrackerProduct(productId: string, xApiKey: string, request?: UpdateTrackerProductRequest, options?: RequestOptions): Promise<TrackerProductSubscription>,
}

/**
 * ProductsApi - factory function to inject configuration 
 * @export
 */
export const ProductsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ProductsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Get the products for the authenticated user
         * @throws {RequiredError}
         */
        getAllProducts(xApiKey: string, options?: RequestOptions = {}): Promise<Array<ProductMenuOption>> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).getAllProducts(xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Admin role
         * @summary Get a product and its settings
         * @throws {RequiredError}
         */
        getProductById(productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<ProductSubscription> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).getProductById(productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Admin role
         * @summary Update a keeper instance\'s name
         * @throws {RequiredError}
         */
        updateKeeperProduct(productId: string, xApiKey: string, request?: UpdateKeeperProductRequest, options?: RequestOptions = {}): Promise<KeeperProductSubscription> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).updateKeeperProduct(productId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * When the Mode is set to API: Signatures must be provided on Contract Creation, Allow non-email Signers, Users cannot sign Contracts by themselves.  When the Mode is set to GUI: Signatures cannot be provided on Contract Creation, Only allow signer emails, An email will be sent to ask for a signature after the contract is confirmed in blockchain, Users must sign the contracts either logged in or using the link in the email that was sent.                Requires the Admin role
         * @summary Update a sealer instance\'s name
         * @throws {RequiredError}
         */
        updateSealerProduct(productId: string, xApiKey: string, request?: UpdateSealerProductRequest, options?: RequestOptions = {}): Promise<SealerProductSubscription> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).updateSealerProduct(productId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Admin role
         * @summary Update a tracker instance\'s name
         * @throws {RequiredError}
         */
        updateTrackerProduct(productId: string, xApiKey: string, request?: UpdateTrackerProductRequest, options?: RequestOptions = {}): Promise<TrackerProductSubscription> {
            const localVarFetchArgs = ProductsApiFetchParamCreator(configuration).updateTrackerProduct(productId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * SealerApi - fetch parameter creator
 * @export
 */
export const SealerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Compare a local contract file to the unsigned contract document.                Requires the Sealer Admin Role for all contracts, but a Sealer User can compare their signed contract.
         * @summary [CONTRACTS] Compare a local contract file
         * @throws {RequiredError}
         */
        compareContract(contractId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'contractId' is not null or undefined
            if (contractId === null || contractId === undefined) {
                throw new RequiredError('contractId','Required parameter contractId was null or undefined when calling compareContract.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling compareContract.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling compareContract.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling compareContract.');
            }
            const localVarPath = `/sealer/{productId}/contracts/{contractId}/compare/contract`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (mustGenerateCompareResult !== undefined) {
                localVarFormParams.set('mustGenerateCompareResult', ((mustGenerateCompareResult:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compare a local signature file to all the signatures of the contract to see if one matches                Requires the Sealer Admin Role or the Sealer User Role.
         * @summary [CONTRACTS] Compare a local signature
         * @throws {RequiredError}
         */
        compareContractSignature(contractId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'contractId' is not null or undefined
            if (contractId === null || contractId === undefined) {
                throw new RequiredError('contractId','Required parameter contractId was null or undefined when calling compareContractSignature.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling compareContractSignature.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling compareContractSignature.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling compareContractSignature.');
            }
            const localVarPath = `/sealer/{productId}/contracts/{contractId}/compare/signature`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (mustGenerateCompareResult !== undefined) {
                localVarFormParams.set('mustGenerateCompareResult', ((mustGenerateCompareResult:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Sealer Admin Role or the Sealer User Role.
         * @summary [SIGNATURES] Compare a local signature file to a signature
         * @throws {RequiredError}
         */
        compareSignature(signatureId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'signatureId' is not null or undefined
            if (signatureId === null || signatureId === undefined) {
                throw new RequiredError('signatureId','Required parameter signatureId was null or undefined when calling compareSignature.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling compareSignature.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling compareSignature.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling compareSignature.');
            }
            const localVarPath = `/sealer/{productId}/signatures/compare/{signatureId}`
                .replace(`{${"signatureId"}}`, encodeURIComponent(String(signatureId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (mustGenerateCompareResult !== undefined) {
                localVarFormParams.set('mustGenerateCompareResult', ((mustGenerateCompareResult:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Sealer Admin Role.
         * @summary [TEMPLATES] Compare a local template file to the template
         * @throws {RequiredError}
         */
        compareTemplate(templateId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling compareTemplate.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling compareTemplate.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling compareTemplate.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling compareTemplate.');
            }
            const localVarPath = `/sealer/{productId}/templates/compare/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (mustGenerateCompareResult !== undefined) {
                localVarFormParams.set('mustGenerateCompareResult', ((mustGenerateCompareResult:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The contract can also be signed at the same time if signature files are provided at the same time.  If provided, the signature files must match the SignerEmails provided in the same order.  If signatures are not provided, an email will be sent to the users to ask for their signatures when the contract is ready.                Requires the Sealer Admin Role.
         * @summary [CONTRACTS] Create a contract for specified emails
         * @throws {RequiredError}
         */
        createContract(productId: string, xApiKey: string, file: any, displayName: string, signerEmails: Array<string>, signatures: Array<string>, signatureRequestMessage?: string, templateId?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createContract.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createContract.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createContract.');
            }
            // verify required parameter 'displayName' is not null or undefined
            if (displayName === null || displayName === undefined) {
                throw new RequiredError('displayName','Required parameter displayName was null or undefined when calling createContract.');
            }
            // verify required parameter 'signerEmails' is not null or undefined
            if (signerEmails === null || signerEmails === undefined) {
                throw new RequiredError('signerEmails','Required parameter signerEmails was null or undefined when calling createContract.');
            }
            // verify required parameter 'signatures' is not null or undefined
            if (signatures === null || signatures === undefined) {
                throw new RequiredError('signatures','Required parameter signatures was null or undefined when calling createContract.');
            }
            const localVarPath = `/sealer/{productId}/contracts`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (displayName !== undefined) {
                localVarFormParams.set('displayName', ((displayName:any):string));
            }

            if (signatureRequestMessage !== undefined) {
                localVarFormParams.set('signatureRequestMessage', ((signatureRequestMessage:any):string));
            }

            if (signerEmails) {
                    localVarFormParams.set('signerEmails', signerEmails.join(COLLECTION_FORMATS["csv"]));
            }

            if (signatures) {
                    localVarFormParams.set('signatures', signatures.join(COLLECTION_FORMATS["csv"]));
            }

            if (templateId !== undefined) {
                localVarFormParams.set('templateId', ((templateId:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Sealer Admin Role or the Sealer User Role.
         * @summary [SIGNATURES] Create a signature for the authenticated user
         * @throws {RequiredError}
         */
        createSignature(productId: string, xApiKey: string, file: any, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createSignature.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createSignature.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createSignature.');
            }
            const localVarPath = `/sealer/{productId}/signatures`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to regroup contracts.                Requires the Sealer Admin Role.
         * @summary [TEMPLATES] Create a template
         * @throws {RequiredError}
         */
        createTemplate(productId: string, xApiKey: string, file: any, displayName: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createTemplate.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createTemplate.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createTemplate.');
            }
            // verify required parameter 'displayName' is not null or undefined
            if (displayName === null || displayName === undefined) {
                throw new RequiredError('displayName','Required parameter displayName was null or undefined when calling createTemplate.');
            }
            const localVarPath = `/sealer/{productId}/templates`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (displayName !== undefined) {
                localVarFormParams.set('displayName', ((displayName:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cannot be deleted if the contract was signed by at least one person.                Requires the Sealer Admin Role.
         * @summary [CONTRACTS] Delete a contract
         * @throws {RequiredError}
         */
        deleteContract(contractId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'contractId' is not null or undefined
            if (contractId === null || contractId === undefined) {
                throw new RequiredError('contractId','Required parameter contractId was null or undefined when calling deleteContract.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteContract.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling deleteContract.');
            }
            const localVarPath = `/sealer/{productId}/contracts/{contractId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cannot be deleted if it has linked contracts.                Requires the Sealer Admin Role.
         * @summary [TEMPLATES] Delete a template
         * @throws {RequiredError}
         */
        deleteTemplate(templateId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling deleteTemplate.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteTemplate.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling deleteTemplate.');
            }
            const localVarPath = `/sealer/{productId}/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A status defines if the contract is signed, partially signed, currently being signed or unsigned                Require the Sealer Admin Role
         * @summary [CONTRACTS] Get all the contracts grouped by signer
         * @throws {RequiredError}
         */
        getAllContracts(productId: string, xApiKey: string, limit?: number, offset?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAllContracts.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllContracts.');
            }
            const localVarPath = `/sealer/{productId}/contracts`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [SIGNATURES] Get all signatures of the authenticated users
         * @throws {RequiredError}
         */
        getAllSignatures(productId: string, xApiKey: string, limit?: number, offset?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAllSignatures.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllSignatures.');
            }
            const localVarPath = `/sealer/{productId}/signatures`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Sealer Admin Role.
         * @summary [TEMPLATES] Get all templates
         * @throws {RequiredError}
         */
        getAllTemplates(productId: string, xApiKey: string, limit?: number, offset?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAllTemplates.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllTemplates.');
            }
            const localVarPath = `/sealer/{productId}/templates`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require the Sealer Admin Role or Sealer User Role
         * @summary [CONTRACTS] Get all of the authenticated users contracts
         * @throws {RequiredError}
         */
        getAuthenticatedUserContracts(productId: string, xApiKey: string, limit?: number, offset?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAuthenticatedUserContracts.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAuthenticatedUserContracts.');
            }
            const localVarPath = `/sealer/{productId}/contracts/self`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Sealer Admin Role.
         * @summary [TEMPLATES] Get contracts attached to a template
         * @throws {RequiredError}
         */
        getContractsByTemplateId(templateId: string, productId: string, xApiKey: string, limit?: number, offset?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling getContractsByTemplateId.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getContractsByTemplateId.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getContractsByTemplateId.');
            }
            const localVarPath = `/sealer/{productId}/templates/{templateId}/contracts`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [CONTRACTS] Give a link to download the file uploaded to the gcloud bucket
         * @throws {RequiredError}
         */
        getLinkToDownloadOriginalFile(fileId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling getLinkToDownloadOriginalFile.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getLinkToDownloadOriginalFile.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getLinkToDownloadOriginalFile.');
            }
            const localVarPath = `/sealer/{productId}/contracts/download/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Sealer Admin Role.
         * @summary [TEMPLATES] Get a template
         * @throws {RequiredError}
         */
        getTemplateById(templateId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling getTemplateById.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getTemplateById.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getTemplateById.');
            }
            const localVarPath = `/sealer/{productId}/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires to be authenticated to the platform.  The original contract and signature must be provided and a Signature Request Id is used to link the email and the contract Id
         * @summary [CONTRACTS] Sign a contract
         * @throws {RequiredError}
         */
        signContractWhenAuthenticated(contractId: string, productId: string, xApiKey: string, signature: any, contract: any, reuseLastSignature: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'contractId' is not null or undefined
            if (contractId === null || contractId === undefined) {
                throw new RequiredError('contractId','Required parameter contractId was null or undefined when calling signContractWhenAuthenticated.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling signContractWhenAuthenticated.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling signContractWhenAuthenticated.');
            }
            // verify required parameter 'signature' is not null or undefined
            if (signature === null || signature === undefined) {
                throw new RequiredError('signature','Required parameter signature was null or undefined when calling signContractWhenAuthenticated.');
            }
            // verify required parameter 'contract' is not null or undefined
            if (contract === null || contract === undefined) {
                throw new RequiredError('contract','Required parameter contract was null or undefined when calling signContractWhenAuthenticated.');
            }
            // verify required parameter 'reuseLastSignature' is not null or undefined
            if (reuseLastSignature === null || reuseLastSignature === undefined) {
                throw new RequiredError('reuseLastSignature','Required parameter reuseLastSignature was null or undefined when calling signContractWhenAuthenticated.');
            }
            const localVarPath = `/sealer/{productId}/contracts/{contractId}/sign`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            if (signature !== undefined) {
                localVarFormParams.set('signature', ((signature:any):string));
            }

            if (contract !== undefined) {
                localVarFormParams.set('contract', ((contract:any):string));
            }

            if (reuseLastSignature !== undefined) {
                localVarFormParams.set('reuseLastSignature', ((reuseLastSignature:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type SealerApiType = { 
    compareContract(contractId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions): Promise<SealerBreadcrumbingCompareResponse>,

    compareContractSignature(contractId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions): Promise<ContractSignatureDiffResponse>,

    compareSignature(signatureId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions): Promise<SealerBreadcrumbingCompareResponse>,

    compareTemplate(templateId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions): Promise<SealerBreadcrumbingCompareResponse>,

    createContract(productId: string, xApiKey: string, file: any, displayName: string, signerEmails: Array<string>, signatures: Array<string>, signatureRequestMessage?: string, templateId?: string, options?: RequestOptions): Promise<Contract>,

    createSignature(productId: string, xApiKey: string, file: any, options?: RequestOptions): Promise<Signature>,

    createTemplate(productId: string, xApiKey: string, file: any, displayName: string, options?: RequestOptions): Promise<Template>,

    deleteContract(contractId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,

    deleteTemplate(templateId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,

    getAllContracts(productId: string, xApiKey: string, limit?: number, offset?: number, options?: RequestOptions): Promise<Array<Contract>>,

    getAllSignatures(productId: string, xApiKey: string, limit?: number, offset?: number, options?: RequestOptions): Promise<Array<Contract>>,

    getAllTemplates(productId: string, xApiKey: string, limit?: number, offset?: number, options?: RequestOptions): Promise<Array<Template>>,

    getAuthenticatedUserContracts(productId: string, xApiKey: string, limit?: number, offset?: number, options?: RequestOptions): Promise<Array<Contract>>,

    getContractsByTemplateId(templateId: string, productId: string, xApiKey: string, limit?: number, offset?: number, options?: RequestOptions): Promise<Array<Contract>>,

    getLinkToDownloadOriginalFile(fileId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<string>,

    getTemplateById(templateId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<Template>,

    signContractWhenAuthenticated(contractId: string, productId: string, xApiKey: string, signature: any, contract: any, reuseLastSignature: boolean, options?: RequestOptions): Promise<Response>,
}

/**
 * SealerApi - factory function to inject configuration 
 * @export
 */
export const SealerApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): SealerApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Compare a local contract file to the unsigned contract document.                Requires the Sealer Admin Role for all contracts, but a Sealer User can compare their signed contract.
         * @summary [CONTRACTS] Compare a local contract file
         * @throws {RequiredError}
         */
        compareContract(contractId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions = {}): Promise<SealerBreadcrumbingCompareResponse> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).compareContract(contractId, productId, xApiKey, file, mustGenerateCompareResult, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Compare a local signature file to all the signatures of the contract to see if one matches                Requires the Sealer Admin Role or the Sealer User Role.
         * @summary [CONTRACTS] Compare a local signature
         * @throws {RequiredError}
         */
        compareContractSignature(contractId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions = {}): Promise<ContractSignatureDiffResponse> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).compareContractSignature(contractId, productId, xApiKey, file, mustGenerateCompareResult, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Sealer Admin Role or the Sealer User Role.
         * @summary [SIGNATURES] Compare a local signature file to a signature
         * @throws {RequiredError}
         */
        compareSignature(signatureId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions = {}): Promise<SealerBreadcrumbingCompareResponse> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).compareSignature(signatureId, productId, xApiKey, file, mustGenerateCompareResult, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Sealer Admin Role.
         * @summary [TEMPLATES] Compare a local template file to the template
         * @throws {RequiredError}
         */
        compareTemplate(templateId: string, productId: string, xApiKey: string, file: any, mustGenerateCompareResult?: boolean, options?: RequestOptions = {}): Promise<SealerBreadcrumbingCompareResponse> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).compareTemplate(templateId, productId, xApiKey, file, mustGenerateCompareResult, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * The contract can also be signed at the same time if signature files are provided at the same time.  If provided, the signature files must match the SignerEmails provided in the same order.  If signatures are not provided, an email will be sent to the users to ask for their signatures when the contract is ready.                Requires the Sealer Admin Role.
         * @summary [CONTRACTS] Create a contract for specified emails
         * @throws {RequiredError}
         */
        createContract(productId: string, xApiKey: string, file: any, displayName: string, signerEmails: Array<string>, signatures: Array<string>, signatureRequestMessage?: string, templateId?: string, options?: RequestOptions = {}): Promise<Contract> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).createContract(productId, xApiKey, file, displayName, signerEmails, signatures, signatureRequestMessage, templateId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Sealer Admin Role or the Sealer User Role.
         * @summary [SIGNATURES] Create a signature for the authenticated user
         * @throws {RequiredError}
         */
        createSignature(productId: string, xApiKey: string, file: any, options?: RequestOptions = {}): Promise<Signature> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).createSignature(productId, xApiKey, file, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Used to regroup contracts.                Requires the Sealer Admin Role.
         * @summary [TEMPLATES] Create a template
         * @throws {RequiredError}
         */
        createTemplate(productId: string, xApiKey: string, file: any, displayName: string, options?: RequestOptions = {}): Promise<Template> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).createTemplate(productId, xApiKey, file, displayName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Cannot be deleted if the contract was signed by at least one person.                Requires the Sealer Admin Role.
         * @summary [CONTRACTS] Delete a contract
         * @throws {RequiredError}
         */
        deleteContract(contractId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).deleteContract(contractId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Cannot be deleted if it has linked contracts.                Requires the Sealer Admin Role.
         * @summary [TEMPLATES] Delete a template
         * @throws {RequiredError}
         */
        deleteTemplate(templateId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).deleteTemplate(templateId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * A status defines if the contract is signed, partially signed, currently being signed or unsigned                Require the Sealer Admin Role
         * @summary [CONTRACTS] Get all the contracts grouped by signer
         * @throws {RequiredError}
         */
        getAllContracts(productId: string, xApiKey: string, limit?: number, offset?: number, options?: RequestOptions = {}): Promise<Array<Contract>> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).getAllContracts(productId, xApiKey, limit, offset, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary [SIGNATURES] Get all signatures of the authenticated users
         * @throws {RequiredError}
         */
        getAllSignatures(productId: string, xApiKey: string, limit?: number, offset?: number, options?: RequestOptions = {}): Promise<Array<Contract>> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).getAllSignatures(productId, xApiKey, limit, offset, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Sealer Admin Role.
         * @summary [TEMPLATES] Get all templates
         * @throws {RequiredError}
         */
        getAllTemplates(productId: string, xApiKey: string, limit?: number, offset?: number, options?: RequestOptions = {}): Promise<Array<Template>> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).getAllTemplates(productId, xApiKey, limit, offset, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Require the Sealer Admin Role or Sealer User Role
         * @summary [CONTRACTS] Get all of the authenticated users contracts
         * @throws {RequiredError}
         */
        getAuthenticatedUserContracts(productId: string, xApiKey: string, limit?: number, offset?: number, options?: RequestOptions = {}): Promise<Array<Contract>> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).getAuthenticatedUserContracts(productId, xApiKey, limit, offset, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Sealer Admin Role.
         * @summary [TEMPLATES] Get contracts attached to a template
         * @throws {RequiredError}
         */
        getContractsByTemplateId(templateId: string, productId: string, xApiKey: string, limit?: number, offset?: number, options?: RequestOptions = {}): Promise<Array<Contract>> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).getContractsByTemplateId(templateId, productId, xApiKey, limit, offset, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary [CONTRACTS] Give a link to download the file uploaded to the gcloud bucket
         * @throws {RequiredError}
         */
        getLinkToDownloadOriginalFile(fileId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).getLinkToDownloadOriginalFile(fileId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Sealer Admin Role.
         * @summary [TEMPLATES] Get a template
         * @throws {RequiredError}
         */
        getTemplateById(templateId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Template> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).getTemplateById(templateId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires to be authenticated to the platform.  The original contract and signature must be provided and a Signature Request Id is used to link the email and the contract Id
         * @summary [CONTRACTS] Sign a contract
         * @throws {RequiredError}
         */
        signContractWhenAuthenticated(contractId: string, productId: string, xApiKey: string, signature: any, contract: any, reuseLastSignature: boolean, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = SealerApiFetchParamCreator(configuration).signContractWhenAuthenticated(contractId, productId, xApiKey, signature, contract, reuseLastSignature, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * TrackerApi - fetch parameter creator
 * @export
 */
export const TrackerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This asset will then be issuable and transferable between entities.                Requires the Tracker Admin Role.
         * @summary [ASSETS] Create an asset
         * @throws {RequiredError}
         */
        createAsset(productId: string, xApiKey: string, request?: TrackerAssetCreateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createAsset.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createAsset.');
            }
            const localVarPath = `/tracker/{productId}/assets`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The authenticated must have the specific batches                Requires the Tracker Admin Role or Tracker User Role.  If you want to transfer to an entity, you should put the id of it.
         * @summary [ASSETS] Create a transfer for one or many batches for an asset
         * @throws {RequiredError}
         */
        createAssetBatchTransfer(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, request?: TrackerBatchTransferRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling createAssetBatchTransfer.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createAssetBatchTransfer.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createAssetBatchTransfer.');
            }
            const localVarPath = `/tracker/{productId}/assets/{assetId}/batches/transfer`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (ownedDisplayName !== undefined && ownedDisplayName !== null) {
                localVarHeaderParameter['ownedDisplayName'] = ((ownedDisplayName:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.  If you want to transfer to an entity, you should put the id of it.
         * @summary [ASSETS] Create a transfer for an asset
         * @throws {RequiredError}
         */
        createAssetTransfer(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, request?: TrackerTransferRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling createAssetTransfer.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createAssetTransfer.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createAssetTransfer.');
            }
            const localVarPath = `/tracker/{productId}/assets/{assetId}/transfer`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (ownedDisplayName !== undefined && ownedDisplayName !== null) {
                localVarHeaderParameter['ownedDisplayName'] = ((ownedDisplayName:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.  If you want to transfer to an entity, you should put the id of it.
         * @summary [ASSETS] Create transfers in bulk
         * @throws {RequiredError}
         */
        createAssetTransferBulk(productId: string, xApiKey: string, ownedId?: string, requests?: Array<TrackerBatchTransferBulkRequest>, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createAssetTransferBulk.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createAssetTransferBulk.');
            }
            const localVarPath = `/tracker/{productId}/assets/transfer/bulk`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (ownedId !== undefined && ownedId !== null) {
                localVarHeaderParameter['ownedId'] = ((ownedId:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof requests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requests != null ? requests : {}) : (((requests:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [ENTITIES] Create an entity
         * @throws {RequiredError}
         */
        createEntity(productId: string, xApiKey: string, request?: CreateEntityRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createEntity.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createEntity.');
            }
            const localVarPath = `/tracker/{productId}/entities`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This asset will then be issuable and transferable between entities.                Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Creates a multi asset
         * @throws {RequiredError}
         */
        createMultiAsset(productId: string, xApiKey: string, request?: TrackerMultiAssetCreateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createMultiAsset.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createMultiAsset.');
            }
            const localVarPath = `/tracker/{productId}/multiassets`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The authenticated must have the specific batches                Requires the Tracker Admin Role or Tracker User Role.
         * @summary [MULTIASSETS] Create a transfer for one or many batches for a multi asset
         * @throws {RequiredError}
         */
        createMultiAssetBatchTransfer(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, request?: TrackerBatchTransferRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling createMultiAssetBatchTransfer.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createMultiAssetBatchTransfer.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createMultiAssetBatchTransfer.');
            }
            const localVarPath = `/tracker/{productId}/multiassets/{assetId}/batches/transfer`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (ownedDisplayName !== undefined && ownedDisplayName !== null) {
                localVarHeaderParameter['ownedDisplayName'] = ((ownedDisplayName:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.
         * @summary [MULTIASSETS] Create a transfer for a multi asset
         * @throws {RequiredError}
         */
        createMultiAssetTransfer(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, request?: TrackerTransferRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling createMultiAssetTransfer.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createMultiAssetTransfer.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createMultiAssetTransfer.');
            }
            const localVarPath = `/tracker/{productId}/multiassets/{assetId}/transfer`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (ownedDisplayName !== undefined && ownedDisplayName !== null) {
                localVarHeaderParameter['ownedDisplayName'] = ((ownedDisplayName:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It won\'t be issuable and transferable anymore, but all transactions made in the past with this asset will still be visible.                Requires the Tracker Admin Role.
         * @summary [ASSETS] Delete an asset
         * @throws {RequiredError}
         */
        deleteAsset(assetId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling deleteAsset.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteAsset.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling deleteAsset.');
            }
            const localVarPath = `/tracker/{productId}/assets/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [ENTITIES] Delete an entity
         * @throws {RequiredError}
         */
        deleteEntity(id: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteEntity.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteEntity.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling deleteEntity.');
            }
            const localVarPath = `/tracker/{productId}/entities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It won\'t be issuable and transferable anymore, but all transactions made in the past with this multi asset will still be visible.                Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Delete a multi asset
         * @throws {RequiredError}
         */
        deleteMultiAsset(assetId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling deleteMultiAsset.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteMultiAsset.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling deleteMultiAsset.');
            }
            const localVarPath = `/tracker/{productId}/multiassets/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only the name can be changed.                Requires the Tracker Admin Role.
         * @summary [ASSETS] Edit an asset
         * @throws {RequiredError}
         */
        editAsset(assetId: string, productId: string, xApiKey: string, request?: TrackerAssetCreateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling editAsset.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling editAsset.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling editAsset.');
            }
            const localVarPath = `/tracker/{productId}/assets/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [ENTITIES] Edit an entity
         * @throws {RequiredError}
         */
        editEntity(id: string, productId: string, xApiKey: string, request?: UpdateEntityRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling editEntity.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling editEntity.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling editEntity.');
            }
            const localVarPath = `/tracker/{productId}/entities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only the name can be changed.                Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Edit a multi asset
         * @throws {RequiredError}
         */
        editMultiAsset(assetId: string, productId: string, xApiKey: string, request?: TrackerAssetCreateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling editMultiAsset.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling editMultiAsset.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling editMultiAsset.');
            }
            const localVarPath = `/tracker/{productId}/multiassets/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [ASSETS] Get all assets
         * @throws {RequiredError}
         */
        getAllAssets(productId: string, xApiKey: string, limit?: number, offset?: number, assetDisplayNames?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAllAssets.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllAssets.');
            }
            const localVarPath = `/tracker/{productId}/assets`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (assetDisplayNames !== undefined) {
                localVarQueryParameter['assetDisplayNames'] = ((assetDisplayNames:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Get all multi assets
         * @throws {RequiredError}
         */
        getAllMultiAssets(productId: string, xApiKey: string, beforeDateTime?: Date, limit?: number, offset?: number, assetIds?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAllMultiAssets.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllMultiAssets.');
            }
            const localVarPath = `/tracker/{productId}/multiassets`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (beforeDateTime !== undefined) {
                localVarQueryParameter['beforeDateTime'] = ((beforeDateTime:any):Date).toISOString();
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (assetIds !== undefined) {
                localVarQueryParameter['assetIds'] = ((assetIds:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [TRANSACTIONS] Get all transactions
         * @throws {RequiredError}
         */
        getAllTransactions(productId: string, xApiKey: string, beforeDateTime?: Date, limit?: number, offset?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAllTransactions.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllTransactions.');
            }
            const localVarPath = `/tracker/{productId}/transactions`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (beforeDateTime !== undefined) {
                localVarQueryParameter['beforeDateTime'] = ((beforeDateTime:any):Date).toISOString();
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [ASSETS] Get a specific asset\'s details
         * @throws {RequiredError}
         */
        getAssetById(assetId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling getAssetById.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAssetById.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAssetById.');
            }
            const localVarPath = `/tracker/{productId}/assets/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.
         * @summary [BALANCES] Get all authenticated user\'s asset balance batches
         * @throws {RequiredError}
         */
        getAssetDetailedBalance(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling getAssetDetailedBalance.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAssetDetailedBalance.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAssetDetailedBalance.');
            }
            const localVarPath = `/tracker/{productId}/balances/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (ownedDisplayName !== undefined && ownedDisplayName !== null) {
                localVarHeaderParameter['ownedDisplayName'] = ((ownedDisplayName:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [ASSETS] Get all transactions of a specific batch for an asset
         * @throws {RequiredError}
         */
        getAssetIssuedBatchTransactions(assetId: string, batchId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling getAssetIssuedBatchTransactions.');
            }
            // verify required parameter 'batchId' is not null or undefined
            if (batchId === null || batchId === undefined) {
                throw new RequiredError('batchId','Required parameter batchId was null or undefined when calling getAssetIssuedBatchTransactions.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAssetIssuedBatchTransactions.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAssetIssuedBatchTransactions.');
            }
            const localVarPath = `/tracker/{productId}/assets/{assetId}/batches/{batchId}/transactions`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"batchId"}}`, encodeURIComponent(String(batchId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [ASSETS] Get all issued batches for an asset
         * @throws {RequiredError}
         */
        getAssetIssuedBatches(assetId: string, productId: string, xApiKey: string, sortBy?: string, sort?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling getAssetIssuedBatches.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getAssetIssuedBatches.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAssetIssuedBatches.');
            }
            const localVarPath = `/tracker/{productId}/assets/{assetId}/batches`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = ((sortBy:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.
         * @summary [BALANCES] Get all authenticated user\'s assets balances
         * @throws {RequiredError}
         */
        getBalances(productId: string, xApiKey: string, ownedDisplayName?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getBalances.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getBalances.');
            }
            const localVarPath = `/tracker/{productId}/balances`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (ownedDisplayName !== undefined && ownedDisplayName !== null) {
                localVarHeaderParameter['ownedDisplayName'] = ((ownedDisplayName:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Track Admin Role.
         * @summary [MULTIASSETS] Get a specific multi asset\'s details
         * @throws {RequiredError}
         */
        getMultiAssetById(assetId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling getMultiAssetById.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getMultiAssetById.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getMultiAssetById.');
            }
            const localVarPath = `/tracker/{productId}/multiassets/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Get all transactions of a specific batch for a multi asset
         * @throws {RequiredError}
         */
        getMultiAssetIssuedBatchTransactions(assetId: string, batchId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling getMultiAssetIssuedBatchTransactions.');
            }
            // verify required parameter 'batchId' is not null or undefined
            if (batchId === null || batchId === undefined) {
                throw new RequiredError('batchId','Required parameter batchId was null or undefined when calling getMultiAssetIssuedBatchTransactions.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getMultiAssetIssuedBatchTransactions.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getMultiAssetIssuedBatchTransactions.');
            }
            const localVarPath = `/tracker/{productId}/multiassets/{assetId}/batches/{batchId}/transactions`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"batchId"}}`, encodeURIComponent(String(batchId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Get all issued batches for a multi asset
         * @throws {RequiredError}
         */
        getMultiAssetIssuedBatches(assetId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling getMultiAssetIssuedBatches.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getMultiAssetIssuedBatches.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getMultiAssetIssuedBatches.');
            }
            const localVarPath = `/tracker/{productId}/multiassets/{assetId}/batches`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary [ENTITIES] Get all entities of a user
         * @throws {RequiredError}
         */
        getOwnedIdentities(productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getOwnedIdentities.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getOwnedIdentities.');
            }
            const localVarPath = `/tracker/{productId}/entities`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.
         * @summary [ASSETS] Get all transactions for an asset
         * @throws {RequiredError}
         */
        getTransactionsByAssetId(assetId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling getTransactionsByAssetId.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getTransactionsByAssetId.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getTransactionsByAssetId.');
            }
            const localVarPath = `/tracker/{productId}/assets/{assetId}/transactions`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.
         * @summary [MULTIASSETS] Get all transactions for a multi asset
         * @throws {RequiredError}
         */
        getTransactionsByMultiAssetId(assetId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling getTransactionsByMultiAssetId.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getTransactionsByMultiAssetId.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getTransactionsByMultiAssetId.');
            }
            const localVarPath = `/tracker/{productId}/multiassets/{assetId}/transactions`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role. If you want to transfer to an entity, you should put the id of it.
         * @summary [ASSETS] Issue an amount of an asset
         * @throws {RequiredError}
         */
        issueAsset(assetId: string, productId: string, xApiKey: string, request?: TrackerAssetIssueRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling issueAsset.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling issueAsset.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling issueAsset.');
            }
            const localVarPath = `/tracker/{productId}/assets/{assetId}/issue`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role.  If you want to transfer to an entity, you should put the id of it.
         * @summary [ASSETS] Issue in bulk
         * @throws {RequiredError}
         */
        issueAssetBulk(productId: string, xApiKey: string, requests?: Array<TrackerAssetIssueBulkRequest>, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling issueAssetBulk.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling issueAssetBulk.');
            }
            const localVarPath = `/tracker/{productId}/assets/issue/bulk`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof requests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requests != null ? requests : {}) : (((requests:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Issue an amount of a multi asset
         * @throws {RequiredError}
         */
        issueMultiAsset(assetId: string, productId: string, xApiKey: string, request?: TrackerAssetIssueRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling issueMultiAsset.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling issueMultiAsset.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling issueMultiAsset.');
            }
            const localVarPath = `/tracker/{productId}/multiassets/{assetId}/issue`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Issue multi asset in bulk
         * @throws {RequiredError}
         */
        issueMultiAssetBulk(productId: string, xApiKey: string, requests?: Array<TrackerAssetIssueBulkRequest>, options: RequestOptions): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling issueMultiAssetBulk.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling issueMultiAssetBulk.');
            }
            const localVarPath = `/tracker/{productId}/multiassets/issue/bulk`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof requests !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requests != null ? requests : {}) : (((requests:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation will refund the amounts that have been sent from a user to another by creating a new transaction.                Requires the Tracker Admin Role.
         * @summary [TRANSACTIONS] Revert a transaction
         * @throws {RequiredError}
         */
        reverse(transactionId: string, productId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling reverse.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling reverse.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling reverse.');
            }
            const localVarPath = `/tracker/{productId}/transactions/{transactionId}/reverse`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)))
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TrackerApiType = { 
    createAsset(productId: string, xApiKey: string, request?: TrackerAssetCreateRequest, options?: RequestOptions): Promise<TrackerAsset>,

    createAssetBatchTransfer(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, request?: TrackerBatchTransferRequest, options?: RequestOptions): Promise<Response>,

    createAssetTransfer(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, request?: TrackerTransferRequest, options?: RequestOptions): Promise<Array<AssetTransaction>>,

    createAssetTransferBulk(productId: string, xApiKey: string, ownedId?: string, requests?: Array<TrackerBatchTransferBulkRequest>, options?: RequestOptions): Promise<Array<TrackerBatchTransferBulkResponse>>,

    createEntity(productId: string, xApiKey: string, request?: CreateEntityRequest, options?: RequestOptions): Promise<NonUser>,

    createMultiAsset(productId: string, xApiKey: string, request?: TrackerMultiAssetCreateRequest, options?: RequestOptions): Promise<TrackerMultiAsset>,

    createMultiAssetBatchTransfer(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, request?: TrackerBatchTransferRequest, options?: RequestOptions): Promise<Response>,

    createMultiAssetTransfer(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, request?: TrackerTransferRequest, options?: RequestOptions): Promise<Array<AssetTransaction>>,

    deleteAsset(assetId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,

    deleteEntity(id: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,

    deleteMultiAsset(assetId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,

    editAsset(assetId: string, productId: string, xApiKey: string, request?: TrackerAssetCreateRequest, options?: RequestOptions): Promise<Response>,

    editEntity(id: string, productId: string, xApiKey: string, request?: UpdateEntityRequest, options?: RequestOptions): Promise<Response>,

    editMultiAsset(assetId: string, productId: string, xApiKey: string, request?: TrackerAssetCreateRequest, options?: RequestOptions): Promise<Response>,

    getAllAssets(productId: string, xApiKey: string, limit?: number, offset?: number, assetDisplayNames?: string, options?: RequestOptions): Promise<Array<TrackerAsset>>,

    getAllMultiAssets(productId: string, xApiKey: string, beforeDateTime?: Date, limit?: number, offset?: number, assetIds?: string, options?: RequestOptions): Promise<Array<TrackerMultiAsset>>,

    getAllTransactions(productId: string, xApiKey: string, beforeDateTime?: Date, limit?: number, offset?: number, options?: RequestOptions): Promise<Array<AssetTransaction>>,

    getAssetById(assetId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<TrackerAsset>,

    getAssetDetailedBalance(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, options?: RequestOptions): Promise<Array<Batch>>,

    getAssetIssuedBatchTransactions(assetId: string, batchId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<IssuedBatchTransactionsResponse>,

    getAssetIssuedBatches(assetId: string, productId: string, xApiKey: string, sortBy?: string, sort?: string, options?: RequestOptions): Promise<IssuedBatchesResponse>,

    getBalances(productId: string, xApiKey: string, ownedDisplayName?: string, options?: RequestOptions): Promise<Array<AssetBalance>>,

    getMultiAssetById(assetId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<TrackerMultiAsset>,

    getMultiAssetIssuedBatchTransactions(assetId: string, batchId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<IssuedBatchTransactionsResponse>,

    getMultiAssetIssuedBatches(assetId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<IssuedBatchesResponse>,

    getOwnedIdentities(productId: string, xApiKey: string, options?: RequestOptions): Promise<Array<NonUserResponse>>,

    getTransactionsByAssetId(assetId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<Array<AssetTransaction>>,

    getTransactionsByMultiAssetId(assetId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<Array<AssetTransaction>>,

    issueAsset(assetId: string, productId: string, xApiKey: string, request?: TrackerAssetIssueRequest, options?: RequestOptions): Promise<Response>,

    issueAssetBulk(productId: string, xApiKey: string, requests?: Array<TrackerAssetIssueBulkRequest>, options?: RequestOptions): Promise<Array<TrackerAssetIssueResponse>>,

    issueMultiAsset(assetId: string, productId: string, xApiKey: string, request?: TrackerAssetIssueRequest, options?: RequestOptions): Promise<Response>,

    issueMultiAssetBulk(productId: string, xApiKey: string, requests?: Array<TrackerAssetIssueBulkRequest>, options?: RequestOptions): Promise<Array<TrackerAssetIssueResponse>>,

    reverse(transactionId: string, productId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,
}

/**
 * TrackerApi - factory function to inject configuration 
 * @export
 */
export const TrackerApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TrackerApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * This asset will then be issuable and transferable between entities.                Requires the Tracker Admin Role.
         * @summary [ASSETS] Create an asset
         * @throws {RequiredError}
         */
        createAsset(productId: string, xApiKey: string, request?: TrackerAssetCreateRequest, options?: RequestOptions = {}): Promise<TrackerAsset> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).createAsset(productId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * The authenticated must have the specific batches                Requires the Tracker Admin Role or Tracker User Role.  If you want to transfer to an entity, you should put the id of it.
         * @summary [ASSETS] Create a transfer for one or many batches for an asset
         * @throws {RequiredError}
         */
        createAssetBatchTransfer(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, request?: TrackerBatchTransferRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).createAssetBatchTransfer(assetId, productId, xApiKey, ownedDisplayName, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.  If you want to transfer to an entity, you should put the id of it.
         * @summary [ASSETS] Create a transfer for an asset
         * @throws {RequiredError}
         */
        createAssetTransfer(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, request?: TrackerTransferRequest, options?: RequestOptions = {}): Promise<Array<AssetTransaction>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).createAssetTransfer(assetId, productId, xApiKey, ownedDisplayName, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.  If you want to transfer to an entity, you should put the id of it.
         * @summary [ASSETS] Create transfers in bulk
         * @throws {RequiredError}
         */
        createAssetTransferBulk(productId: string, xApiKey: string, ownedId?: string, requests?: Array<TrackerBatchTransferBulkRequest>, options?: RequestOptions = {}): Promise<Array<TrackerBatchTransferBulkResponse>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).createAssetTransferBulk(productId, xApiKey, ownedId, requests, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary [ENTITIES] Create an entity
         * @throws {RequiredError}
         */
        createEntity(productId: string, xApiKey: string, request?: CreateEntityRequest, options?: RequestOptions = {}): Promise<NonUser> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).createEntity(productId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This asset will then be issuable and transferable between entities.                Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Creates a multi asset
         * @throws {RequiredError}
         */
        createMultiAsset(productId: string, xApiKey: string, request?: TrackerMultiAssetCreateRequest, options?: RequestOptions = {}): Promise<TrackerMultiAsset> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).createMultiAsset(productId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * The authenticated must have the specific batches                Requires the Tracker Admin Role or Tracker User Role.
         * @summary [MULTIASSETS] Create a transfer for one or many batches for a multi asset
         * @throws {RequiredError}
         */
        createMultiAssetBatchTransfer(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, request?: TrackerBatchTransferRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).createMultiAssetBatchTransfer(assetId, productId, xApiKey, ownedDisplayName, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.
         * @summary [MULTIASSETS] Create a transfer for a multi asset
         * @throws {RequiredError}
         */
        createMultiAssetTransfer(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, request?: TrackerTransferRequest, options?: RequestOptions = {}): Promise<Array<AssetTransaction>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).createMultiAssetTransfer(assetId, productId, xApiKey, ownedDisplayName, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * It won\'t be issuable and transferable anymore, but all transactions made in the past with this asset will still be visible.                Requires the Tracker Admin Role.
         * @summary [ASSETS] Delete an asset
         * @throws {RequiredError}
         */
        deleteAsset(assetId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).deleteAsset(assetId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary [ENTITIES] Delete an entity
         * @throws {RequiredError}
         */
        deleteEntity(id: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).deleteEntity(id, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * It won\'t be issuable and transferable anymore, but all transactions made in the past with this multi asset will still be visible.                Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Delete a multi asset
         * @throws {RequiredError}
         */
        deleteMultiAsset(assetId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).deleteMultiAsset(assetId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Only the name can be changed.                Requires the Tracker Admin Role.
         * @summary [ASSETS] Edit an asset
         * @throws {RequiredError}
         */
        editAsset(assetId: string, productId: string, xApiKey: string, request?: TrackerAssetCreateRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).editAsset(assetId, productId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary [ENTITIES] Edit an entity
         * @throws {RequiredError}
         */
        editEntity(id: string, productId: string, xApiKey: string, request?: UpdateEntityRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).editEntity(id, productId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Only the name can be changed.                Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Edit a multi asset
         * @throws {RequiredError}
         */
        editMultiAsset(assetId: string, productId: string, xApiKey: string, request?: TrackerAssetCreateRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).editMultiAsset(assetId, productId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [ASSETS] Get all assets
         * @throws {RequiredError}
         */
        getAllAssets(productId: string, xApiKey: string, limit?: number, offset?: number, assetDisplayNames?: string, options?: RequestOptions = {}): Promise<Array<TrackerAsset>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getAllAssets(productId, xApiKey, limit, offset, assetDisplayNames, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Get all multi assets
         * @throws {RequiredError}
         */
        getAllMultiAssets(productId: string, xApiKey: string, beforeDateTime?: Date, limit?: number, offset?: number, assetIds?: string, options?: RequestOptions = {}): Promise<Array<TrackerMultiAsset>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getAllMultiAssets(productId, xApiKey, beforeDateTime, limit, offset, assetIds, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [TRANSACTIONS] Get all transactions
         * @throws {RequiredError}
         */
        getAllTransactions(productId: string, xApiKey: string, beforeDateTime?: Date, limit?: number, offset?: number, options?: RequestOptions = {}): Promise<Array<AssetTransaction>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getAllTransactions(productId, xApiKey, beforeDateTime, limit, offset, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [ASSETS] Get a specific asset\'s details
         * @throws {RequiredError}
         */
        getAssetById(assetId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<TrackerAsset> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getAssetById(assetId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.
         * @summary [BALANCES] Get all authenticated user\'s asset balance batches
         * @throws {RequiredError}
         */
        getAssetDetailedBalance(assetId: string, productId: string, xApiKey: string, ownedDisplayName?: string, options?: RequestOptions = {}): Promise<Array<Batch>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getAssetDetailedBalance(assetId, productId, xApiKey, ownedDisplayName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [ASSETS] Get all transactions of a specific batch for an asset
         * @throws {RequiredError}
         */
        getAssetIssuedBatchTransactions(assetId: string, batchId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<IssuedBatchTransactionsResponse> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getAssetIssuedBatchTransactions(assetId, batchId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [ASSETS] Get all issued batches for an asset
         * @throws {RequiredError}
         */
        getAssetIssuedBatches(assetId: string, productId: string, xApiKey: string, sortBy?: string, sort?: string, options?: RequestOptions = {}): Promise<IssuedBatchesResponse> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getAssetIssuedBatches(assetId, productId, xApiKey, sortBy, sort, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.
         * @summary [BALANCES] Get all authenticated user\'s assets balances
         * @throws {RequiredError}
         */
        getBalances(productId: string, xApiKey: string, ownedDisplayName?: string, options?: RequestOptions = {}): Promise<Array<AssetBalance>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getBalances(productId, xApiKey, ownedDisplayName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Track Admin Role.
         * @summary [MULTIASSETS] Get a specific multi asset\'s details
         * @throws {RequiredError}
         */
        getMultiAssetById(assetId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<TrackerMultiAsset> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getMultiAssetById(assetId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Get all transactions of a specific batch for a multi asset
         * @throws {RequiredError}
         */
        getMultiAssetIssuedBatchTransactions(assetId: string, batchId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<IssuedBatchTransactionsResponse> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getMultiAssetIssuedBatchTransactions(assetId, batchId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Get all issued batches for a multi asset
         * @throws {RequiredError}
         */
        getMultiAssetIssuedBatches(assetId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<IssuedBatchesResponse> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getMultiAssetIssuedBatches(assetId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary [ENTITIES] Get all entities of a user
         * @throws {RequiredError}
         */
        getOwnedIdentities(productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Array<NonUserResponse>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getOwnedIdentities(productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.
         * @summary [ASSETS] Get all transactions for an asset
         * @throws {RequiredError}
         */
        getTransactionsByAssetId(assetId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Array<AssetTransaction>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getTransactionsByAssetId(assetId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role or Tracker User Role.
         * @summary [MULTIASSETS] Get all transactions for a multi asset
         * @throws {RequiredError}
         */
        getTransactionsByMultiAssetId(assetId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Array<AssetTransaction>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).getTransactionsByMultiAssetId(assetId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role. If you want to transfer to an entity, you should put the id of it.
         * @summary [ASSETS] Issue an amount of an asset
         * @throws {RequiredError}
         */
        issueAsset(assetId: string, productId: string, xApiKey: string, request?: TrackerAssetIssueRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).issueAsset(assetId, productId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role.  If you want to transfer to an entity, you should put the id of it.
         * @summary [ASSETS] Issue in bulk
         * @throws {RequiredError}
         */
        issueAssetBulk(productId: string, xApiKey: string, requests?: Array<TrackerAssetIssueBulkRequest>, options?: RequestOptions = {}): Promise<Array<TrackerAssetIssueResponse>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).issueAssetBulk(productId, xApiKey, requests, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Issue an amount of a multi asset
         * @throws {RequiredError}
         */
        issueMultiAsset(assetId: string, productId: string, xApiKey: string, request?: TrackerAssetIssueRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).issueMultiAsset(assetId, productId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the Tracker Admin Role.
         * @summary [MULTIASSETS] Issue multi asset in bulk
         * @throws {RequiredError}
         */
        issueMultiAssetBulk(productId: string, xApiKey: string, requests?: Array<TrackerAssetIssueBulkRequest>, options?: RequestOptions = {}): Promise<Array<TrackerAssetIssueResponse>> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).issueMultiAssetBulk(productId, xApiKey, requests, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This operation will refund the amounts that have been sent from a user to another by creating a new transaction.                Requires the Tracker Admin Role.
         * @summary [TRANSACTIONS] Revert a transaction
         * @throws {RequiredError}
         */
        reverse(transactionId: string, productId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = TrackerApiFetchParamCreator(configuration).reverse(transactionId, productId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a specific user. This will prevent this user from accessing the platform and will delete their API key if  they had one.                Requires the User Admin Role.
         * @summary Delete a user
         * @throws {RequiredError}
         */
        deleteUser(userId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUser.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will prevent this user from accessing the platform and will delete their API key if they had one.                Requires the User Admin Role.
         * @summary Disable a user
         * @throws {RequiredError}
         */
        disableUser(userId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling disableUser.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling disableUser.');
            }
            const localVarPath = `/users/{userId}/disable`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If their roles are changed, it will also delete their access token and they will need to login again next time.                Requires the User Admin Role.
         * @summary Edit a user\'s details
         * @throws {RequiredError}
         */
        editUser(userId: string, xApiKey: string, request?: EditUserRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling editUser.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling editUser.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request != null ? request : {}) : (((request:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will let this user access the platform again. If the user needs an API key, it will need to be regenerated.                Requires the User Admin Role.
         * @summary Enable a user
         * @throws {RequiredError}
         */
        enableUser(userId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling enableUser.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling enableUser.');
            }
            const localVarPath = `/users/{userId}/enable`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Details on the authenticated user                Requires the User Admin Role.
         * @summary Get the authenticated user
         * @throws {RequiredError}
         */
        get(xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling get.');
            }
            const localVarPath = `/users/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires the User Admin Role.
         * @summary Get all users
         * @throws {RequiredError}
         */
        getAllUsers(xApiKey: string, isEnabled?: boolean, limit?: number, offset?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAllUsers.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (isEnabled !== undefined) {
                localVarQueryParameter['isEnabled'] = ((isEnabled:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific user\'s details.                Requires the User Admin Role.
         * @summary Get a user
         * @throws {RequiredError}
         */
        getUserById(userId: string, xApiKey: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserById.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getUserById.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = ((xApiKey:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UsersApiType = { 
    deleteUser(userId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,

    disableUser(userId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,

    editUser(userId: string, xApiKey: string, request?: EditUserRequest, options?: RequestOptions): Promise<Response>,

    enableUser(userId: string, xApiKey: string, options?: RequestOptions): Promise<Response>,

    get(xApiKey: string, options?: RequestOptions): Promise<User>,

    getAllUsers(xApiKey: string, isEnabled?: boolean, limit?: number, offset?: number, options?: RequestOptions): Promise<Array<User>>,

    getUserById(userId: string, xApiKey: string, options?: RequestOptions): Promise<User>,
}

/**
 * UsersApi - factory function to inject configuration 
 * @export
 */
export const UsersApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UsersApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Delete a specific user. This will prevent this user from accessing the platform and will delete their API key if  they had one.                Requires the User Admin Role.
         * @summary Delete a user
         * @throws {RequiredError}
         */
        deleteUser(userId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(userId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * This will prevent this user from accessing the platform and will delete their API key if they had one.                Requires the User Admin Role.
         * @summary Disable a user
         * @throws {RequiredError}
         */
        disableUser(userId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).disableUser(userId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * If their roles are changed, it will also delete their access token and they will need to login again next time.                Requires the User Admin Role.
         * @summary Edit a user\'s details
         * @throws {RequiredError}
         */
        editUser(userId: string, xApiKey: string, request?: EditUserRequest, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).editUser(userId, xApiKey, request, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * This will let this user access the platform again. If the user needs an API key, it will need to be regenerated.                Requires the User Admin Role.
         * @summary Enable a user
         * @throws {RequiredError}
         */
        enableUser(userId: string, xApiKey: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).enableUser(userId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * Details on the authenticated user                Requires the User Admin Role.
         * @summary Get the authenticated user
         * @throws {RequiredError}
         */
        get(xApiKey: string, options?: RequestOptions = {}): Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).get(xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Requires the User Admin Role.
         * @summary Get all users
         * @throws {RequiredError}
         */
        getAllUsers(xApiKey: string, isEnabled?: boolean, limit?: number, offset?: number, options?: RequestOptions = {}): Promise<Array<User>> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getAllUsers(xApiKey, isEnabled, limit, offset, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get a specific user\'s details.                Requires the User Admin Role.
         * @summary Get a user
         * @throws {RequiredError}
         */
        getUserById(userId: string, xApiKey: string, options?: RequestOptions = {}): Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserById(userId, xApiKey, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

export type ApiTypes = { 
    ApiKeysApi: ApiKeysApiType,

    InvitationsApi: InvitationsApiType,

    KeeperApi: KeeperApiType,

    ProductsApi: ProductsApiType,

    SealerApi: SealerApiType,

    TrackerApi: TrackerApiType,

    UsersApi: UsersApiType,
 }
